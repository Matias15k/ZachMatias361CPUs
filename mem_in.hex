B7      // [0x00] LUI   x5, 0x12345        (opcode=0110111)
52      
34
12

17      // [0x04] AUIPC x10, 0x00001       (opcode=0010111)
15
00
00

EF      // [0x08] JAL   x1, +24            (0x018000EF) ... x1 has 0x0C now
00      
80
01

13      // [0x0C] NOP (ADDI x0, x0, 0)
00
00
00
13      // [0x10] NOP
00
00
00
13      // [0x14] NOP
00
00
00
13      // [0x18] NOP
00
00
00
13      // [0x1C] NOP
00
00
00

67      // [0x20] JALR  x2, x1, +24        (0x01808167) → x2 = 0x24, PC → 0x24
81
80
01

63      // [0x24] BEQ x5, x6, +8    (0x02518063) //Branch NOT taken, increment pc as usual. x5 and x6 have differing content
80
51
02

63      // [0x28] BEQ x0, x6, +16    (0x02320063) //Branch taken, increment pc by 16, x0 and x6 have same content
00
32
02

13      // [0x2c] NOP
00
00
00

13      // [0x30] NOP
00
00
00

13      // [0x34] NOP
00
00
00

63      // [0x38] BNE x1, x2, +16    (0x02111063) //Branch taken, increment pc by 16, x1 and x2 have differing content
10
11
02

13      // [0x3c] NOP
00
00
00

13      // [0x40] NOP
00
00
00

13      // [0x44] NOP
00
00
00

63      // [0x48] BLT                      (0x02114063)
40      //reg 1 < reg 2. blt reg2 reg1;  2114063, should not branch
11  
02

63      // [0x4c] BLT                      (0x0020C863) 
C8      //reg 1 < reg 2. blt reg1 reg2;  0220C063, should branch, pc = pc + 16
20
00

13      // [0x50] NOP
00
00
00

13      // [0x54] NOP
00
00
00

13      // [0x58] NOP
00
00
00

//b type general structure: 0000001 00001  00010   101     00000  1100011
//                          +16      rs2   rs1    func3            opcode                                    

//reg5 > reg1, bge reg1 reg5;  0220C063, should not branch, pc = pc + 4
// 0000001 00101 00001 101 00000 1100011 => 0x0250D063
63     // [0x5c] BGE 
D0
50
02

//contents of reg 31: 00000001
//contents of reg 30: 10000000
//bge reg31 reg30;  01FF5863, should NOT branch, pc = pc + 16
// 0000000 11111 11110 101 10000 1100011 => 0x01FF5863
63     // [0x60] BGE (signed)
58
FF
01

//contents of reg 31: 00000001
//contents of reg 30: 10000000
//bgeu reg30 reg31;  01EFF863, should branch, pc + 16
// 0000000 11111 11110 111 10000 1100011 => 0x01FF7863
63     // [0x64] BGEU (unsigned)
78
FF
01


13      // [0x68] NOP
00
00
00

13      // [0x6c] NOP
00
00
00

13      // [0x70] NOP
00
00
00
                      
//contents of reg 29: FF000000
//contents of reg 28: 00000011
//bltu reg28 reg29; should branch, pc + 16
// 0000000 11101 11100 110 10000 1100011 => 0x01DE6863
63     // [0x74] BLTU
68
DE
01

13      // [0x78] NOP
00
00
00

13      // [0x7c] NOP
00
00
00

13      // [0x80] NOP
00
00
00

//contents of reg 29: FF000000
//contents of reg 28: 00000011
//blt reg28 reg29; should not branch, pc + 16
// 0000000 11101 11100 100 10000 1100011 => 0x01DE4863
63     // [0x84] BLT (signed)
48
DE
01

//Load instruction general instruction pattern
// offset(12b)      rs1(5b)    000.     rd(5b).    0000011

// load r7, 5(r27)
//set r27 to contain 0x0000005f
//63     // [0x64] BGEU (unsigned)
//78
//FF
//01
//Correct response: r7 should have 63 stored in increment; PC increments normally 
// offset(12b)      rs1(5b)    000     rd(5b).    0000011
// 000000000101     11011      000     00111      0000011 ==> 0x005D8383
83       // [0x88]
83
5D
00

// load r8, 5(r27) halfword
//set r27 to contain 0x0000005f
//63     // [0x64] BGEU (unsigned)
//78
//FF
//01
//Correct response: r8 should have 7863 stored in increment; PC increments normally 
// offset(12b)      rs1(5b)    000     rd(5b).    0000011
// 000000000101     11011      000     01000      0000011 
// 00000000010111011001010000000011 ==> 0x005D9403 
03       // [0x8c]
94
5D
00

// load r9, 5(r27) word
//set r27 to contain 0x0000005f
//63     // [0x64] BGEU (unsigned)
//78
//FF
//01
//Correct response: r9 should have 01FF7863 stored in increment; PC increments normally 
// offset(12b)      rs1(5b)    000     rd(5b).    0000011
// 000000000101     11011      010     01001      0000011 
//00000000010111011010010010000011
//  ==> 0x005DA483
83       // [0x90]
A4
5D
00

// store r26, 4(r25) ; byte-sb
//set r26 to contain 143999ae
//set r25 to contain 00000290
// 0x00000290 location has xxxxx rn 
//Correct response: mem location 00000295 should have 'ae' stored in increment; PC increments normally 
// offset(7b)      rs2(5b)  rs1(5b)  000   offset(5b)    0100011
// 0000000         11010    11001    000     00100       0100011 
//
// 00000001101011001000001000100011  ==> 0x01AC8223
23       // [0x94]
82
AC
01


// store r26, 6(r25) ; byte-sh
//set r26 to contain 143999ae
//set r25 to contain 00000290
// 0x00000290 location has xxxxx rn 
//Correct response: mem location 00000295 should have '99ae' stored in increment; PC increments normally 
// offset(7b)      rs2(5b)  rs1(5b)  000   offset(5b)    0100011
// 0000000         11010    11001    001     00110       0100011 
//
// 00000001101011001001001100100011  ==> 0x01AC9323
23       // [0x98]
93
AC
01

// store r26, 5(r25) ; byte-sw
//set r26 to contain 143999ae
//set r25 to contain 00000290
// 0x00000290 location has xxxxx rn 
// offset(7b)      rs2(5b)  rs1(5b)  000   offset(5b)    0100011
// 0000000         11010    11001    010     01110       0100011 
//
// 00000001101011001010011100100011  ==> 0x01ACA723
23       // [0x9c]
A7
AC
01

73      // [0xA0] HALT                    (0x00000073)
00
00
00
